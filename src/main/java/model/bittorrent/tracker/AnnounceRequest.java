package model.bittorrent.tracker;

import org.apache.commons.codec.net.URLCodec;

import java.nio.charset.StandardCharsets;

/**
 * The tracker is an HTTP/HTTPS service which responds to HTTP GET requests.
 * The requests include metrics from clients that help the tracker keep overall
 * statistics about the torrent. The base URL consists of the "announce URL" as
 * defined in the metainfo (.torrent) file. The parameters are then added to this URL,
 * using standard CGI methods (i.e. a '?' after the announce URL, followed by 'param=value'
 * sequences separated by '&').
 * <p>
 * Note that all binary data in the URL (particularly info_hash and peer_id) must
 * be properly escaped. This means any byte not in the set 0-9, a-z, A-Z, '.', '-', '_' and '~',
 * must be encoded using the "%nn" format, where nn is the hexadecimal
 * value of the byte. (See RFC1738 for details.)
 *
 * @author Adrien Lacroix
 * @version 0.2.0
 */
public class AnnounceRequest {
	/**
	 * Base URL of the request.
	 */
	private String announceURL;

	/**
	 * urlencoded 20-byte SHA1 hash of the value of the info key from the Metainfo file.
	 * Note that the value will be a bencoded dictionary, given the definition of the info key above.
	 */
	private byte[] infoHash;
	public final static String INFO_HASH = "info_hash";

	/**
	 * urlencoded 20-byte string used as a unique ID for the client, generated by the client at startup.
	 * This is allowed to be any value, and may be binary data. There are currently no guidelines for
	 * generating this peer ID. However, one may rightly presume that it must at least be unique for
	 * your local machine, thus should probably incorporate things like process ID and perhaps a
	 * timestamp recorded at startup.
	 */
	private byte[] peerID;
	public final static String PEER_ID = "peer_id";

	/**
	 * The port number that the client is listening on. Ports reserved for BitTorrent are
	 * typically 6881-6889. Clients may choose to give up if it cannot establish a port within this range.
	 */
	private int port;
	public final static String PORT = "port";

	/**
	 * The total amount uploaded (since the client sent the 'started' event to the tracker)
	 * in base ten ASCII.
	 * <p>
	 * While not explicitly stated in the official specification, the concensus is that this
	 * should be the total number of bytes uploaded.
	 */
	private int uploaded;
	public final static String UPLOADED = "uploaded";

	/**
	 * The total amount downloaded (since the client sent the 'started' event to the tracker)
	 * in base ten ASCII.
	 * <p>
	 * While not explicitly stated in the official specification, the consensus is that this
	 * should be the total number of bytes downloaded.
	 */
	private int downloaded;
	public final static String DOWNLOADED = "downloaded";

	/**
	 * The number of bytes this client still has to download in base ten ASCII.
	 * <p>
	 * Clarification: The number of bytes needed to download to be 100% complete and
	 * get all the included files in the torrent.
	 */
	private int left;
	public final static String LEFT = "left";

	/**
	 * Setting this to 1 indicates that the client accepts a compact response.
	 * <p>
	 * The peers list is replaced by a peers string with 6 bytes per peer.
	 * The first four bytes are the host (in network byte order), the last two bytes
	 * are the port (again in network byte order). It should be noted that some
	 * trackers only support compact responses (for saving bandwidth) and either
	 * refuse requests without "compact=1" or simply send a compact response unless
	 * the request contains "compact=0" (in which case they will refuse the request.)
	 */
	private int compact;
	public final static String COMPACT = "compact";

	/**
	 * Indicates that the tracker can omit peer id field in peers dictionary.
	 * This option is ignored if compact is enabled.
	 */
	private int noPeerId;
	public final static String NO_PEER_ID = "no_peer_id";

	/**
	 * If specified, must be one of started, completed, stopped, (or empty which is the same
	 * as not being specified). If not specified, then this request is one performed at regular intervals.
	 * <p>
	 * - started: The first request to the tracker must include the event key with this value.
	 * - stopped: Must be sent to the tracker if the client is shutting down gracefully.
	 * - completed: Must be sent to the tracker when the download completes. However, must not be sent if
	 * the download was already 100% complete when the client started. Presumably, this is to allow the
	 * tracker to increment the "completed downloads" metric based solely on this event.
	 */
	private Event event;
	public final static String EVENT = "event";

	public enum Event {STARTED, STOPPED, COMPLETED}

	/**
	 * Optional. The true IP address of the client machine, in dotted quad format or
	 * rfc3513 defined hexed IPv6 address.
	 * <p>
	 * Notes: In general this parameter is not necessary as the address of the client can
	 * be determined from the IP address from which the HTTP request came. The parameter is
	 * only needed in the case where the IP address that the request came in on is not the IP
	 * address of the client. This happens if the client is communicating to the tracker through
	 * a proxy (or a transparent web proxy/cache.) It also is necessary when both the client and
	 * the tracker are on the same local side of a NAT gateway. The reason for this is that
	 * otherwise the tracker would give out the internal (RFC1918) address of the client, which
	 * is not routable. Therefore the client must explicitly state its (external, routable) IP
	 * address to be given out to external peers. Various trackers treat this parameter differently.
	 * Some only honor it only if the IP address that the request came in on is in RFC1918 space.
	 * Others honor it unconditionally, while others ignore it completely. In case of IPv6 address
	 * (e.g.: 2001:db8:1:2::100) it indicates only that client can communicate via IPv6.
	 */
	private String ip;
	public final static String IP = "ip";

	/**
	 * Optional. Number of peers that the client would like to receive from the tracker.
	 * <p>
	 * This value is permitted to be zero. If omitted, typically defaults to 50 peers.
	 */
	private Integer numWant;
	public final static String NUMWANT = "numwant";

	/**
	 * Optional. An additional client identification mechanism that is not shared with any peers.
	 * <p>
	 * It is intended to allow a client to prove their identity should their IP address change.
	 */
	private String key;
	public final static String KEY = "key";

	/**
	 * Optional. If a previous announce contained a tracker id, it should be set here.
	 */
	private byte[] trackerID;
	public final static String TRACKERID = "trackerid";

	public AnnounceRequest(String announceURL, byte[] infoHash, byte[] peerID, int port,
	                       int uploaded, int downloaded, int left, int compact, int noPeerId, Event event) {
		this(announceURL, infoHash, peerID, port, uploaded, downloaded, left, compact, noPeerId, event,
				null, null, null, null);
	}

	public AnnounceRequest(String announceURL, byte[] infoHash, byte[] peerID, int port, int uploaded,
	                       int downloaded, int left, int compact, int noPeerId, Event event, String ip,
	                       Integer numWant, String key, byte[] trackerID) {
		this.announceURL = announceURL;
		this.infoHash = infoHash;
		this.peerID = peerID;
		this.port = port;
		this.uploaded = uploaded;
		this.downloaded = downloaded;
		this.left = left;
		this.compact = compact;
		this.noPeerId = noPeerId;
		this.event = event;
		this.ip = ip;
		this.numWant = numWant;
		this.key = key;
		this.trackerID = trackerID;
	}

	public String getRequest() {
		StringBuilder builder = new StringBuilder();
		URLCodec codec = new URLCodec();

		// announce url
		builder.append(announceURL);
		// add arguments
		builder.append('?');
		// info hash
		builder.append(INFO_HASH).append('=').append(new String(codec.encode(infoHash), StandardCharsets.UTF_8));
		// peer id
		builder.append('&').append(PEER_ID).append('=').append(new String(codec.encode(peerID), StandardCharsets.UTF_8));
		// port
		builder.append('&').append(PORT).append('=').append(port);
		// uploaded
		builder.append('&').append(UPLOADED).append('=').append(uploaded);
		// downloaded
		builder.append('&').append(DOWNLOADED).append('=').append(downloaded);
		// left
		builder.append('&').append(LEFT).append('=').append(left);
		// compact
		builder.append('&').append(COMPACT).append('=').append(compact);
		// no peer id
		if (compact == 0) {
			builder.append('&').append(NO_PEER_ID).append('=').append(noPeerId);
		}
		// event
		if (event != null) {
			builder.append('&').append(EVENT).append('=').append(event.toString().toLowerCase());
		}
		// ip
		if (ip != null) {
			builder.append('&').append(IP).append('=').append(ip);
		}
		// numWant
		if (numWant != null) {
			builder.append('&').append(NUMWANT).append('=').append(numWant);
		}
		// key
		if (key != null) {
			builder.append('&').append(KEY).append('=').append(key);
		}
		// tracker id
		if (trackerID != null) {
			builder.append('&').append(TRACKERID).append('=').append(new String(trackerID));
		}

		return builder.toString();
	}
}
